module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[project]/lib/supabase/server.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$8$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$86$2e$2$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@supabase+ssr@0.8.0_@supabase+supabase-js@2.86.2/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$8$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$86$2e$2$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@supabase+ssr@0.8.0_@supabase+supabase-js@2.86.2/node_modules/@supabase/ssr/dist/module/createServerClient.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.7_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/next/headers.js [app-route] (ecmascript)");
;
;
async function createClient() {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$8$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$86$2e$2$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createServerClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createServerClient"])(("TURBOPACK compile-time value", "https://smftrbuactkjjeeqgzkf.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNtZnRyYnVhY3RramplZXFnemtmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUxNzYzMzQsImV4cCI6MjA4MDc1MjMzNH0.YSsB7vq-DPho3etILJo0Np-z8P_iIivmJk5ToMT6e1k"), {
        cookies: {
            getAll () {
                return cookieStore.getAll();
            },
            setAll (cookiesToSet) {
                try {
                    cookiesToSet.forEach(({ name, value, options })=>cookieStore.set(name, value, options));
                } catch  {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing
                // user sessions.
                }
            }
        }
    });
}
}),
"[project]/lib/supabase/client.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClient",
    ()=>createClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$8$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$86$2e$2$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@supabase+ssr@0.8.0_@supabase+supabase-js@2.86.2/node_modules/@supabase/ssr/dist/module/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$8$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$86$2e$2$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createBrowserClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@supabase+ssr@0.8.0_@supabase+supabase-js@2.86.2/node_modules/@supabase/ssr/dist/module/createBrowserClient.js [app-route] (ecmascript)");
;
function createClient() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$supabase$2b$ssr$40$0$2e$8$2e$0_$40$supabase$2b$supabase$2d$js$40$2$2e$86$2e$2$2f$node_modules$2f40$supabase$2f$ssr$2f$dist$2f$module$2f$createBrowserClient$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createBrowserClient"])(("TURBOPACK compile-time value", "https://smftrbuactkjjeeqgzkf.supabase.co"), ("TURBOPACK compile-time value", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNtZnRyYnVhY3RramplZXFnemtmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUxNzYzMzQsImV4cCI6MjA4MDc1MjMzNH0.YSsB7vq-DPho3etILJo0Np-z8P_iIivmJk5ToMT6e1k"), {
        realtime: {
            params: {
                eventsPerSecond: 10
            }
        }
    });
}
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[project]/lib/away-message.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sendAwayMessageIfEnabled",
    ()=>sendAwayMessageIfEnabled
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase/db.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$13$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2d$node$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/uuid@13.0.0/node_modules/uuid/dist-node/v4.js [app-route] (ecmascript) <export default as v4>");
;
;
async function sendAwayMessageIfEnabled(conversationId, businessId) {
    try {
        // Get business to check away message settings
        const business = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].getBusinessById(businessId);
        if (!business) {
            console.warn("Business not found for away message:", businessId);
            return;
        }
        // Check if away message is enabled and message exists
        if (!business.awayMessageEnabled || !business.awayMessage?.trim()) {
            return; // Away message not enabled or no message set
        }
        // Get conversation to check if this is the first interaction
        const conversation = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].getConversationById(conversationId);
        if (!conversation) {
            console.warn("Conversation not found for away message:", conversationId);
            return;
        }
        // Only send away message if this is the customer's first time messaging
        // Check if there are any previous business messages in this conversation
        // If there are any business messages, it means they've interacted before
        const businessMessages = conversation.messages.filter((m)=>m.senderType === "business");
        if (businessMessages.length > 0) {
            // Business has already messaged this customer before, don't send away message
            return;
        }
        // Also check if we've already sent an away message (to prevent duplicates in race conditions)
        // This handles the case where multiple customer messages arrive before the away message is created
        const hasAwayMessage = conversation.messages.some((m)=>m.senderType === "business" && m.text === business.awayMessage?.trim());
        if (hasAwayMessage) {
            // Away message already exists, don't send again
            return;
        }
        // Create and send the away message
        const awayMessage = {
            id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$uuid$40$13$2e$0$2e$0$2f$node_modules$2f$uuid$2f$dist$2d$node$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])(),
            conversationId: conversationId,
            senderType: "business",
            senderId: businessId,
            text: business.awayMessage.trim(),
            status: "sent",
            createdAt: new Date().toISOString()
        };
        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].createMessage(awayMessage);
        console.log("✅ Away message sent automatically to conversation:", conversationId);
    } catch (error) {
        console.error("❌ Error sending away message:", error);
    // Don't throw - we don't want to fail the original message if away message fails
    }
}
}),
"[project]/lib/egress-monitor.ts [app-route] (client reference proxy) <module evaluation>", ((__turbopack_context__) => {
"use strict";

// This file is generated by next-core EcmascriptClientReferenceModule.
__turbopack_context__.s([
    "egressMonitor",
    ()=>egressMonitor,
    "monitorRequest",
    ()=>monitorRequest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.7_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-route] (ecmascript)");
;
const egressMonitor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call egressMonitor() from the server but egressMonitor is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/lib/egress-monitor.ts <module evaluation>", "egressMonitor");
const monitorRequest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call monitorRequest() from the server but monitorRequest is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/lib/egress-monitor.ts <module evaluation>", "monitorRequest");
}),
"[project]/lib/egress-monitor.ts [app-route] (client reference proxy)", ((__turbopack_context__) => {
"use strict";

// This file is generated by next-core EcmascriptClientReferenceModule.
__turbopack_context__.s([
    "egressMonitor",
    ()=>egressMonitor,
    "monitorRequest",
    ()=>monitorRequest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.7_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-route] (ecmascript)");
;
const egressMonitor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call egressMonitor() from the server but egressMonitor is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/lib/egress-monitor.ts", "egressMonitor");
const monitorRequest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call monitorRequest() from the server but monitorRequest is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/lib/egress-monitor.ts", "monitorRequest");
}),
"[project]/lib/egress-monitor.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/lib/egress-monitor.ts [app-route] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/lib/egress-monitor.ts [app-route] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/lib/supabase/db.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "db",
    ()=>db
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase/client.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$away$2d$message$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/away-message.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/egress-monitor.ts [app-route] (ecmascript)");
;
;
;
// Convert DB Business to App Business
function dbBusinessToApp(db) {
    return {
        id: db.id,
        email: db.email,
        phone: db.phone || "",
        businessName: db.business_name || "",
        businessLogo: db.business_logo || undefined,
        address: db.address || "",
        online: db.online ?? false,
        createdAt: db.created_at,
        awayMessage: db.away_message || undefined,
        awayMessageEnabled: db.away_message_enabled ?? false,
        isAdmin: db.is_admin ?? false
    };
}
// Convert App Business to DB Business
function appBusinessToDB(business, passwordHash) {
    const dbData = {};
    // Only include fields that are actually provided (not undefined)
    if (business.email !== undefined) {
        dbData.email = business.email;
    }
    if (passwordHash !== undefined && passwordHash !== "") {
        dbData.password_hash = passwordHash;
    }
    if (business.businessName !== undefined) {
        // Convert empty string to null for database
        dbData.business_name = business.businessName.trim() || null;
    }
    if (business.phone !== undefined) {
        // Convert empty string to null for database
        dbData.phone = business.phone.trim() || null;
    }
    if (business.address !== undefined) {
        // Convert empty string to null for database
        dbData.address = business.address.trim() || null;
    }
    if (business.businessLogo !== undefined) {
        dbData.business_logo = business.businessLogo || null;
    }
    if (business.awayMessage !== undefined) {
        dbData.away_message = business.awayMessage.trim() || null;
    }
    if (business.awayMessageEnabled !== undefined) {
        dbData.away_message_enabled = business.awayMessageEnabled;
    }
    return dbData;
}
// Convert DB Conversation to App Conversation (with messages)
async function dbConversationToApp(db, messages = []) {
    // Create a map of messages by ID for quick lookup
    const messagesMap = new Map();
    messages.forEach((m)=>messagesMap.set(m.id, m));
    // Convert messages and resolve replyTo references
    const appMessages = messages.map((m)=>{
        const message = {
            id: m.id,
            conversationId: m.conversation_id,
            senderType: m.sender_type,
            senderId: m.sender_id,
            text: m.content || undefined,
            imageUrl: m.image_url || undefined,
            status: m.status || "sent",
            createdAt: m.created_at,
            replyToId: m.reply_to_id || undefined
        };
        // If this message is a reply, find and attach the original message
        if (m.reply_to_id) {
            const replyToMessage = messagesMap.get(m.reply_to_id);
            if (replyToMessage) {
                message.replyTo = {
                    id: replyToMessage.id,
                    conversationId: replyToMessage.conversation_id,
                    senderType: replyToMessage.sender_type,
                    senderId: replyToMessage.sender_id,
                    text: replyToMessage.content || undefined,
                    imageUrl: replyToMessage.image_url || undefined,
                    status: replyToMessage.status || "sent",
                    createdAt: replyToMessage.created_at
                };
            }
        }
        return message;
    });
    return {
        id: db.id,
        businessId: db.business_id,
        customerEmail: db.customer_email,
        customerName: db.customer_name || undefined,
        createdAt: db.created_at,
        lastMessageAt: db.updated_at,
        messages: appMessages,
        pinned: db.pinned ?? false
    };
}
// Convert App Conversation to DB Conversation
function appConversationToDB(conversation, customerPhone) {
    return {
        business_id: conversation.businessId,
        customer_phone: customerPhone || "",
        customer_email: conversation.customerEmail || undefined
    };
}
// Convert App Message to DB Message
function appMessageToDB(message) {
    return {
        conversation_id: message.conversationId,
        sender_type: message.senderType,
        sender_id: message.senderId || "",
        content: message.text || null,
        image_url: message.imageUrl || null,
        status: message.status || "sent",
        reply_to_id: message.replyToId || null
    };
}
const db = {
    // Businesses
    async getBusinessById (id) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data, error } = await supabase.from("businesses").select("id, email, password_hash, business_name, phone, address, business_logo, online, away_message, away_message_enabled, is_admin, created_at, updated_at").eq("id", id).maybeSingle() // Use maybeSingle() to handle missing businesses gracefully
        ;
        if (error || !data) return null;
        return dbBusinessToApp(data);
    },
    async getBusinessByEmail (email) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data, error } = await supabase.from("businesses").select("id, email, password_hash, business_name, phone, address, business_logo, online, away_message, away_message_enabled, is_admin, created_at, updated_at").eq("email", email).maybeSingle() // Use maybeSingle() to handle missing businesses gracefully
        ;
        if (error || !data) return null;
        return dbBusinessToApp(data);
    },
    async getBusinessByPhone (phone) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data, error } = await supabase.from("businesses").select("id, email, password_hash, business_name, phone, address, business_logo, online, away_message, away_message_enabled, is_admin, created_at, updated_at").eq("phone", phone).maybeSingle() // Use maybeSingle() to handle missing businesses gracefully
        ;
        if (error || !data) return null;
        return dbBusinessToApp(data);
    },
    async createBusiness (business, passwordHash = "") {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const dbData = {
            id: business.id,
            email: business.email,
            password_hash: passwordHash,
            business_name: business.businessName || null,
            phone: business.phone || null,
            address: business.address || null,
            business_logo: business.businessLogo || null
        };
        const { data, error } = await supabase.from("businesses").insert(dbData).select().single();
        if (error) throw error;
        return dbBusinessToApp(data);
    },
    async updateBusiness (id, updates) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const dbData = appBusinessToDB(updates);
        // Make sure to include business_logo if it's being updated
        if (updates.businessLogo !== undefined) {
            dbData.business_logo = updates.businessLogo || null;
        }
        // Try to include online status if it's being updated
        // If the column doesn't exist yet, we'll skip it and continue with other updates
        if (updates.online !== undefined) {
            // Check if online column exists by trying a test query first
            // For now, we'll include it and let the error be caught if column doesn't exist
            dbData.online = updates.online;
        }
        const { data, error } = await supabase.from("businesses").update(dbData).eq("id", id).select().maybeSingle() // Use maybeSingle() to handle missing businesses gracefully
        ;
        if (error) {
            // If error is about missing 'online' column, try again without it
            if (error.message?.includes("online") && error.code === "PGRST204") {
                console.warn("Online column not found, updating without online status. Please run migration 008_add_online_status.sql");
                delete dbData.online;
                const { data: retryData, error: retryError } = await supabase.from("businesses").update(dbData).eq("id", id).select().maybeSingle() // Use maybeSingle() to handle missing businesses gracefully
                ;
                if (retryError) {
                    console.error("Error updating business:", retryError);
                    throw new Error(retryError.message || "Failed to update business");
                }
                if (!retryData) {
                    throw new Error("No data returned from update");
                }
                return dbBusinessToApp(retryData);
            }
            console.error("Error updating business:", error);
            throw new Error(error.message || "Failed to update business");
        }
        if (!data) {
            throw new Error("No data returned from update");
        }
        return dbBusinessToApp(data);
    },
    // Conversations
    async getConversationsByBusinessId (businessId) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data: conversations, error } = await supabase.from("conversations").select("id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned").eq("business_id", businessId).order("updated_at", {
            ascending: false
        });
        if (error || !conversations || conversations.length === 0) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["monitorRequest"])("getConversationsByBusinessId", []);
            return [];
        }
        const conversationIds = conversations.map((c)=>c.id);
        // Optimized: Fetch only last message per conversation + unread count in parallel
        // This is much faster than fetching all messages
        const [lastMessagesResults, unreadCountsResults] = await Promise.all([
            // Fetch only the last message for preview - use selective fields
            Promise.all(conversationIds.map(async (conversationId)=>{
                const { data: messages } = await supabase.from("messages").select("id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id").eq("conversation_id", conversationId).order("created_at", {
                    ascending: false
                }).limit(1) // Only get the last message for preview
                ;
                return {
                    conversationId,
                    lastMessage: messages && messages.length > 0 ? messages[0] : null
                };
            })),
            // Efficiently calculate unread counts using a count query
            Promise.all(conversationIds.map(async (conversationId)=>{
                const { count, error } = await supabase.from("messages").select("id", {
                    count: "exact",
                    head: true
                }).eq("conversation_id", conversationId).eq("sender_type", "customer").in("status", [
                    "sent",
                    "delivered"
                ]) // Unread = sent or delivered from customer
                ;
                // If count query fails, fallback to fetching and counting (but only IDs)
                if (error || count === null) {
                    const { data: unreadMessages } = await supabase.from("messages").select("id").eq("conversation_id", conversationId).eq("sender_type", "customer").in("status", [
                        "sent",
                        "delivered"
                    ]).limit(1000) // Safety limit
                    ;
                    return {
                        conversationId,
                        unreadCount: unreadMessages?.length || 0
                    };
                }
                return {
                    conversationId,
                    unreadCount: count || 0
                };
            }))
        ]);
        // Create maps for quick lookup
        const lastMessageMap = new Map();
        const unreadCountMap = new Map();
        lastMessagesResults.forEach(({ conversationId, lastMessage })=>{
            if (lastMessage) {
                lastMessageMap.set(conversationId, lastMessage);
            }
        });
        unreadCountsResults.forEach(({ conversationId, unreadCount })=>{
            unreadCountMap.set(conversationId, unreadCount);
        });
        // Convert to app format - only include last message, not all messages
        const result = await Promise.all(conversations.map(async (conv)=>{
            const lastMessage = lastMessageMap.get(conv.id);
            const messages = lastMessage ? [
                lastMessage
            ] : [];
            const conversation = await dbConversationToApp(conv, messages);
            // Add unread count to conversation
            conversation.unreadCount = unreadCountMap.get(conv.id) || 0;
            return conversation;
        }));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["monitorRequest"])("getConversationsByBusinessId", result);
        return result;
    },
    async getConversationById (id) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data: conversation, error } = await supabase.from("conversations").select("id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned").eq("id", id).maybeSingle() // Use maybeSingle() to handle missing conversations gracefully
        ;
        if (error || !conversation) return null;
        // Reduced initial message fetch to 25 most recent messages for performance
        // Use selective fields instead of select("*")
        const { data: messages } = await supabase.from("messages").select("id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id").eq("conversation_id", id).order("created_at", {
            ascending: false
        }).limit(25);
        // Reverse to get chronological order (oldest first)
        const sortedMessages = messages ? [
            ...messages
        ].reverse() : [];
        return dbConversationToApp(conversation, sortedMessages || []);
    },
    // Paginated message loading for infinite scroll
    async getMessagesPaginated (conversationId, beforeMessageId, limit = 25) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        let query = supabase.from("messages").select("id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id").eq("conversation_id", conversationId).order("created_at", {
            ascending: false
        }).limit(limit);
        // If beforeMessageId is provided, fetch messages before that message
        if (beforeMessageId) {
            const { data: beforeMessage, error: beforeError } = await supabase.from("messages").select("created_at").eq("id", beforeMessageId).maybeSingle() // Use maybeSingle() instead of single() to handle 0 rows gracefully
            ;
            // Only apply filter if message exists and no error
            if (!beforeError && beforeMessage) {
                query = query.lt("created_at", beforeMessage.created_at);
            } else {
                // If message not found, return empty array (no more messages to load)
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["monitorRequest"])("getMessagesPaginated", []);
                return [];
            }
        }
        const { data: messages, error } = await query;
        if (error || !messages) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["monitorRequest"])("getMessagesPaginated", []);
            return [];
        }
        // Reverse to get chronological order (oldest first)
        const sortedMessages = [
            ...messages
        ].reverse();
        // Convert to app format
        const result = sortedMessages.map((m)=>({
                id: m.id,
                conversationId: m.conversation_id,
                senderType: m.sender_type,
                senderId: m.sender_id,
                text: m.content || undefined,
                imageUrl: m.image_url || undefined,
                status: m.status || "sent",
                createdAt: m.created_at,
                replyToId: m.reply_to_id || undefined
            }));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$egress$2d$monitor$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["monitorRequest"])("getMessagesPaginated", result);
        return result;
    },
    async getConversationByBusinessAndEmail (businessId, customerEmail) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { data: conversation, error } = await supabase.from("conversations").select("id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned").eq("business_id", businessId).eq("customer_email", customerEmail).maybeSingle() // Use maybeSingle() to handle missing conversations gracefully
        ;
        if (error || !conversation) return null;
        // Only fetch last 25 messages instead of all messages
        const { data: messages } = await supabase.from("messages").select("id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id").eq("conversation_id", conversation.id).order("created_at", {
            ascending: false
        }).limit(25);
        // Reverse to get chronological order (oldest first)
        const sortedMessages = messages ? [
            ...messages
        ].reverse() : [];
        return dbConversationToApp(conversation, sortedMessages || []);
    },
    async createConversation (conversation) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const dbData = {
            id: conversation.id,
            business_id: conversation.businessId,
            customer_email: conversation.customerEmail,
            customer_name: conversation.customerName || null,
            customer_phone: null
        };
        const { data, error } = await supabase.from("conversations").insert(dbData).select().single();
        if (error) throw error;
        // Create messages if any
        if (conversation.messages && conversation.messages.length > 0) {
            const messagesData = conversation.messages.map((m)=>({
                    id: m.id,
                    conversation_id: m.conversationId,
                    sender_type: m.senderType,
                    sender_id: m.senderId || conversation.businessId,
                    content: m.text || null,
                    image_url: m.imageUrl || null
                }));
            await supabase.from("messages").insert(messagesData);
        }
        return dbConversationToApp(data, []);
    },
    async updateConversation (id, updates) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const dbData = {};
        if (updates.customerEmail !== undefined) {
            dbData.customer_email = updates.customerEmail;
        }
        if (updates.customerName !== undefined) {
            dbData.customer_name = updates.customerName || null;
        }
        if (updates.pinned !== undefined) {
            dbData.pinned = updates.pinned;
        }
        const { data, error } = await supabase.from("conversations").update(dbData).eq("id", id).select("id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned").maybeSingle() // Use maybeSingle() to handle missing conversations gracefully
        ;
        if (error || !data) return null;
        // Don't fetch all messages on update - just return conversation without messages
        // Messages will be loaded separately via getConversationById or getMessagesPaginated
        return dbConversationToApp(data, []);
    },
    async updateMessageStatus (id, status) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        await supabase.from("messages").update({
            status
        }).eq("id", id);
    },
    async markMessagesAsDelivered (conversationId, senderType) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Mark all messages from the other sender as delivered
        await supabase.from("messages").update({
            status: "delivered"
        }).eq("conversation_id", conversationId).eq("sender_type", senderType).in("status", [
            "sent"
        ]);
    },
    async markMessagesAsRead (conversationId, senderType) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Mark all messages from the other sender as read
        await supabase.from("messages").update({
            status: "read"
        }).eq("conversation_id", conversationId).eq("sender_type", senderType).in("status", [
            "sent",
            "delivered"
        ]);
    },
    async updateMessage (id, updates) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const dbData = {};
        if (updates.text !== undefined) {
            dbData.content = updates.text;
        }
        const { data, error } = await supabase.from("messages").update(dbData).eq("id", id).select("id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id").maybeSingle();
        if (error || !data) return null;
        return {
            id: data.id,
            conversationId: data.conversation_id,
            senderType: data.sender_type,
            senderId: data.sender_id,
            text: data.content || undefined,
            imageUrl: data.image_url || undefined,
            status: data.status || "sent",
            createdAt: data.created_at,
            replyToId: data.reply_to_id || undefined
        };
    },
    async deleteMessage (id) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        await supabase.from("messages").delete().eq("id", id);
    },
    // Messages
    async createMessage (message) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const dbData = {
            id: message.id,
            conversation_id: message.conversationId,
            sender_type: message.senderType,
            sender_id: message.senderId || "",
            content: message.text || null,
            image_url: message.imageUrl || null,
            status: message.status || "sent",
            reply_to_id: message.replyToId || null
        };
        const { data, error } = await supabase.from("messages").insert(dbData).select("id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id").single();
        if (error) throw error;
        // Update conversation's updated_at
        await supabase.from("conversations").update({
            updated_at: new Date().toISOString()
        }).eq("id", message.conversationId);
        // If this is a customer message, trigger away message check (async, don't block)
        if (message.senderType === "customer") {
            // Get business ID from conversation
            const { data: convData, error: convError } = await supabase.from("conversations").select("business_id").eq("id", message.conversationId).maybeSingle() // Use maybeSingle() to handle missing conversations gracefully
            ;
            if (!convError && convData?.business_id) {
                // Send away message asynchronously (fire and forget - don't block message creation)
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$away$2d$message$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["sendAwayMessageIfEnabled"])(message.conversationId, convData.business_id).catch((err)=>console.error("Error sending away message:", err));
            }
        }
        return {
            id: data.id,
            conversationId: data.conversation_id,
            senderType: data.sender_type,
            senderId: data.sender_id,
            text: data.content || undefined,
            imageUrl: data.image_url || undefined,
            status: data.status || "sent",
            createdAt: data.created_at,
            replyToId: data.reply_to_id || undefined
        };
    },
    async deleteConversation (id) {
        const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        const { error } = await supabase.from("conversations").delete().eq("id", id);
        if (error) throw error;
    }
};
}),
"[project]/app/api/admin/check/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.7_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase/server.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/supabase/db.ts [app-route] (ecmascript)");
;
;
;
async function GET() {
    try {
        const supabase = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$server$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createClient"])();
        // Get current user
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                isAdmin: false,
                error: "Not authenticated"
            }, {
                status: 401
            });
        }
        // Get business data to check admin status
        const business = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$supabase$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].getBusinessById(user.id);
        if (!business) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                isAdmin: false,
                error: "Business not found"
            }, {
                status: 404
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            isAdmin: business.isAdmin ?? false,
            businessId: business.id
        });
    } catch (error) {
        console.error("Error checking admin status:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$7_react$2d$dom$40$19$2e$2$2e$1_react$40$19$2e$2$2e$1_$5f$react$40$19$2e$2$2e$1$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            isAdmin: false,
            error: "Failed to check admin status"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__7015ee08._.js.map