{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/supabase/client.ts"],"sourcesContent":["import { createBrowserClient } from \"@supabase/ssr\"\n\nexport function createClient() {\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      realtime: {\n        params: {\n          eventsPerSecond: 10,\n        },\n      },\n    }\n  )\n}\n\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEO,SAAS;IACd,OAAO,IAAA,8SAAmB,sUAGxB;QACE,UAAU;YACR,QAAQ;gBACN,iBAAiB;YACnB;QACF;IACF;AAEJ"}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/away-message.ts"],"sourcesContent":["import { db } from \"./supabase/db\"\nimport type { Message } from \"./types\"\nimport { v4 as uuidv4 } from \"uuid\"\n\n/**\n * Automatically send away message when a customer sends a message\n * This should be called after a customer message is created\n */\nexport async function sendAwayMessageIfEnabled(\n  conversationId: string,\n  businessId: string\n): Promise<void> {\n  try {\n    // Get business to check away message settings\n    const business = await db.getBusinessById(businessId)\n    \n    if (!business) {\n      console.warn(\"Business not found for away message:\", businessId)\n      return\n    }\n\n    // Check if away message is enabled and message exists\n    if (!business.awayMessageEnabled || !business.awayMessage?.trim()) {\n      return // Away message not enabled or no message set\n    }\n\n    // Get conversation to check if this is the first interaction\n    const conversation = await db.getConversationById(conversationId)\n    if (!conversation) {\n      console.warn(\"Conversation not found for away message:\", conversationId)\n      return\n    }\n\n    // Only send away message if this is the customer's first time messaging\n    // Check if there are any previous business messages in this conversation\n    // If there are any business messages, it means they've interacted before\n    const businessMessages = conversation.messages.filter(\n      (m) => m.senderType === \"business\"\n    )\n\n    if (businessMessages.length > 0) {\n      // Business has already messaged this customer before, don't send away message\n      return\n    }\n\n    // Also check if we've already sent an away message (to prevent duplicates in race conditions)\n    // This handles the case where multiple customer messages arrive before the away message is created\n    const hasAwayMessage = conversation.messages.some(\n      (m) => m.senderType === \"business\" && m.text === business.awayMessage?.trim()\n    )\n\n    if (hasAwayMessage) {\n      // Away message already exists, don't send again\n      return\n    }\n\n    // Create and send the away message\n    const awayMessage: Message = {\n      id: uuidv4(),\n      conversationId: conversationId,\n      senderType: \"business\",\n      senderId: businessId,\n      text: business.awayMessage.trim(),\n      status: \"sent\",\n      createdAt: new Date().toISOString(),\n    }\n\n    await db.createMessage(awayMessage)\n    console.log(\"‚úÖ Away message sent automatically to conversation:\", conversationId)\n  } catch (error) {\n    console.error(\"‚ùå Error sending away message:\", error)\n    // Don't throw - we don't want to fail the original message if away message fails\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AAEA;;;AAMO,eAAe,yBACpB,cAAsB,EACtB,UAAkB;IAElB,IAAI;QACF,8CAA8C;QAC9C,MAAM,WAAW,MAAM,2HAAE,CAAC,eAAe,CAAC;QAE1C,IAAI,CAAC,UAAU;YACb,QAAQ,IAAI,CAAC,wCAAwC;YACrD;QACF;QAEA,sDAAsD;QACtD,IAAI,CAAC,SAAS,kBAAkB,IAAI,CAAC,SAAS,WAAW,EAAE,QAAQ;YACjE,QAAO,6CAA6C;QACtD;QAEA,6DAA6D;QAC7D,MAAM,eAAe,MAAM,2HAAE,CAAC,mBAAmB,CAAC;QAClD,IAAI,CAAC,cAAc;YACjB,QAAQ,IAAI,CAAC,4CAA4C;YACzD;QACF;QAEA,wEAAwE;QACxE,yEAAyE;QACzE,yEAAyE;QACzE,MAAM,mBAAmB,aAAa,QAAQ,CAAC,MAAM,CACnD,CAAC,IAAM,EAAE,UAAU,KAAK;QAG1B,IAAI,iBAAiB,MAAM,GAAG,GAAG;YAC/B,8EAA8E;YAC9E;QACF;QAEA,8FAA8F;QAC9F,mGAAmG;QACnG,MAAM,iBAAiB,aAAa,QAAQ,CAAC,IAAI,CAC/C,CAAC,IAAM,EAAE,UAAU,KAAK,cAAc,EAAE,IAAI,KAAK,SAAS,WAAW,EAAE;QAGzE,IAAI,gBAAgB;YAClB,gDAAgD;YAChD;QACF;QAEA,mCAAmC;QACnC,MAAM,cAAuB;YAC3B,IAAI,IAAA,mOAAM;YACV,gBAAgB;YAChB,YAAY;YACZ,UAAU;YACV,MAAM,SAAS,WAAW,CAAC,IAAI;YAC/B,QAAQ;YACR,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,MAAM,2HAAE,CAAC,aAAa,CAAC;QACvB,QAAQ,GAAG,CAAC,sDAAsD;IACpE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;IAC/C,iFAAiF;IACnF;AACF"}},
    {"offset": {"line": 92, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/egress-monitor.ts"],"sourcesContent":["\"use client\"\n\n// Egress monitoring utility to track data usage\ninterface EgressMetrics {\n  totalBytes: number\n  requestCount: number\n  lastUpdated: number\n  byEndpoint: Record<string, { bytes: number; count: number }>\n}\n\nconst STORAGE_KEY = \"leenk_egress_metrics\"\nconst MAX_STORAGE_SIZE = 100 * 1024 * 1024 // 100MB max storage\n\nclass EgressMonitor {\n  private metrics: EgressMetrics = {\n    totalBytes: 0,\n    requestCount: 0,\n    lastUpdated: Date.now(),\n    byEndpoint: {},\n  }\n\n  constructor() {\n    this.loadMetrics()\n  }\n\n  // Load metrics from localStorage\n  private loadMetrics(): void {\n    if (typeof window === \"undefined\") return\n\n    try {\n      const stored = localStorage.getItem(STORAGE_KEY)\n      if (stored) {\n        this.metrics = JSON.parse(stored)\n      }\n    } catch (error) {\n      console.error(\"Error loading egress metrics:\", error)\n    }\n  }\n\n  // Save metrics to localStorage\n  private saveMetrics(): void {\n    if (typeof window === \"undefined\") return\n\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.metrics))\n    } catch (error) {\n      console.error(\"Error saving egress metrics:\", error)\n    }\n  }\n\n  // Estimate response size (rough approximation)\n  private estimateSize(data: any): number {\n    try {\n      const jsonString = JSON.stringify(data)\n      // Rough estimate: UTF-8 encoding, each character is ~1-4 bytes\n      // We'll use a conservative 2 bytes per character\n      return jsonString.length * 2\n    } catch {\n      // Fallback: estimate based on object keys\n      return Object.keys(data || {}).length * 100\n    }\n  }\n\n  // Record a request\n  recordRequest(endpoint: string, responseData: any): void {\n    const bytes = this.estimateSize(responseData)\n    \n    this.metrics.totalBytes += bytes\n    this.metrics.requestCount += 1\n    this.metrics.lastUpdated = Date.now()\n\n    if (!this.metrics.byEndpoint[endpoint]) {\n      this.metrics.byEndpoint[endpoint] = { bytes: 0, count: 0 }\n    }\n    this.metrics.byEndpoint[endpoint].bytes += bytes\n    this.metrics.byEndpoint[endpoint].count += 1\n\n    this.saveMetrics()\n\n    // Log in development\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(`üìä Egress: ${this.formatBytes(bytes)} from ${endpoint}`)\n    }\n  }\n\n  // Get current metrics\n  getMetrics(): EgressMetrics {\n    return { ...this.metrics }\n  }\n\n  // Get formatted summary\n  getSummary(): string {\n    const mb = this.metrics.totalBytes / (1024 * 1024)\n    const gb = mb / 1024\n    \n    let size: string\n    if (gb >= 1) {\n      size = `${gb.toFixed(2)} GB`\n    } else {\n      size = `${mb.toFixed(2)} MB`\n    }\n\n    return `Total: ${size} | Requests: ${this.metrics.requestCount}`\n  }\n\n  // Format bytes to human readable\n  formatBytes(bytes: number): string {\n    if (bytes === 0) return \"0 B\"\n    const k = 1024\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\"]\n    const i = Math.floor(Math.log(bytes) / Math.log(k))\n    return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`\n  }\n\n  // Get top endpoints by usage\n  getTopEndpoints(limit: number = 5): Array<{ endpoint: string; bytes: number; count: number }> {\n    return Object.entries(this.metrics.byEndpoint)\n      .map(([endpoint, data]) => ({\n        endpoint,\n        bytes: data.bytes,\n        count: data.count,\n      }))\n      .sort((a, b) => b.bytes - a.bytes)\n      .slice(0, limit)\n  }\n\n  // Reset metrics\n  reset(): void {\n    this.metrics = {\n      totalBytes: 0,\n      requestCount: 0,\n      lastUpdated: Date.now(),\n      byEndpoint: {},\n    }\n    this.saveMetrics()\n  }\n\n  // Get daily usage (approximate)\n  getDailyUsage(): number {\n    const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000\n    // This is a simplified version - in production you'd track timestamps per request\n    // For now, we'll return total if updated in last 24h, otherwise 0\n    if (this.metrics.lastUpdated > oneDayAgo) {\n      return this.metrics.totalBytes\n    }\n    return 0\n  }\n}\n\n// Singleton instance\nexport const egressMonitor = new EgressMonitor()\n\n// Helper to wrap fetch/API calls\nexport function monitorRequest(endpoint: string, responseData: any): void {\n  egressMonitor.recordRequest(endpoint, responseData)\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/supabase/db.ts"],"sourcesContent":["import { createClient } from \"./client\"\nimport type { Business, Conversation, Message } from \"../types\"\nimport { sendAwayMessageIfEnabled } from \"../away-message\"\nimport { monitorRequest } from \"../egress-monitor\"\n\n// Database types matching the schema\ninterface DBBusiness {\n  id: string\n  email: string\n  password_hash: string\n  business_name: string | null\n  phone: string | null\n  address: string | null\n  business_logo: string | null\n  online: boolean | null\n  away_message: string | null\n  away_message_enabled: boolean | null\n  is_admin: boolean | null\n  created_at: string\n  updated_at: string\n}\n\ninterface DBConversation {\n  id: string\n  business_id: string\n  customer_phone: string | null\n  customer_name: string | null\n  customer_email: string\n  created_at: string\n  updated_at: string\n  pinned: boolean | null\n}\n\ninterface DBMessage {\n  id: string\n  conversation_id: string\n  sender_type: \"business\" | \"customer\"\n  sender_id: string\n  content: string | null\n  image_url: string | null\n  status: \"sent\" | \"delivered\" | \"read\" | null\n  created_at: string\n  reply_to_id: string | null\n}\n\n// Convert DB Business to App Business\nfunction dbBusinessToApp(db: DBBusiness): Business {\n  return {\n    id: db.id,\n    email: db.email,\n    phone: db.phone || \"\",\n    businessName: db.business_name || \"\",\n    businessLogo: db.business_logo || undefined,\n    address: db.address || \"\",\n    online: db.online ?? false, // Read actual online status from database\n    createdAt: db.created_at,\n    awayMessage: db.away_message || undefined,\n    awayMessageEnabled: db.away_message_enabled ?? false,\n    isAdmin: db.is_admin ?? false,\n  }\n}\n\n// Convert App Business to DB Business\nfunction appBusinessToDB(business: Partial<Business>, passwordHash?: string): Partial<DBBusiness> {\n  const dbData: Partial<DBBusiness> = {}\n  \n  // Only include fields that are actually provided (not undefined)\n  if (business.email !== undefined) {\n    dbData.email = business.email\n  }\n  if (passwordHash !== undefined && passwordHash !== \"\") {\n    dbData.password_hash = passwordHash\n  }\n  if (business.businessName !== undefined) {\n    // Convert empty string to null for database\n    dbData.business_name = business.businessName.trim() || null\n  }\n  if (business.phone !== undefined) {\n    // Convert empty string to null for database\n    dbData.phone = business.phone.trim() || null\n  }\n  if (business.address !== undefined) {\n    // Convert empty string to null for database\n    dbData.address = business.address.trim() || null\n  }\n  if (business.businessLogo !== undefined) {\n    dbData.business_logo = business.businessLogo || null\n  }\n  if (business.awayMessage !== undefined) {\n    dbData.away_message = business.awayMessage.trim() || null\n  }\n  if (business.awayMessageEnabled !== undefined) {\n    dbData.away_message_enabled = business.awayMessageEnabled\n  }\n  \n  return dbData\n}\n\n// Convert DB Conversation to App Conversation (with messages)\nasync function dbConversationToApp(\n  db: DBConversation,\n  messages: DBMessage[] = []\n): Promise<Conversation> {\n  // Create a map of messages by ID for quick lookup\n  const messagesMap = new Map<string, DBMessage>()\n  messages.forEach((m) => messagesMap.set(m.id, m))\n\n  // Convert messages and resolve replyTo references\n  const appMessages: Message[] = messages.map((m) => {\n    const message: Message = {\n    id: m.id,\n    conversationId: m.conversation_id,\n    senderType: m.sender_type,\n    senderId: m.sender_id,\n    text: m.content || undefined,\n    imageUrl: m.image_url || undefined,\n    status: (m.status || \"sent\") as \"sent\" | \"delivered\" | \"read\",\n    createdAt: m.created_at,\n      replyToId: m.reply_to_id || undefined,\n    }\n\n    // If this message is a reply, find and attach the original message\n    if (m.reply_to_id) {\n      const replyToMessage = messagesMap.get(m.reply_to_id)\n      if (replyToMessage) {\n        message.replyTo = {\n          id: replyToMessage.id,\n          conversationId: replyToMessage.conversation_id,\n          senderType: replyToMessage.sender_type,\n          senderId: replyToMessage.sender_id,\n          text: replyToMessage.content || undefined,\n          imageUrl: replyToMessage.image_url || undefined,\n          status: (replyToMessage.status || \"sent\") as \"sent\" | \"delivered\" | \"read\",\n          createdAt: replyToMessage.created_at,\n        }\n      }\n    }\n\n    return message\n  })\n\n  return {\n    id: db.id,\n    businessId: db.business_id,\n    customerEmail: db.customer_email,\n    customerName: db.customer_name || undefined,\n    createdAt: db.created_at,\n    lastMessageAt: db.updated_at,\n    messages: appMessages,\n    pinned: db.pinned ?? false,\n  }\n}\n\n// Convert App Conversation to DB Conversation\nfunction appConversationToDB(\n  conversation: Partial<Conversation>,\n  customerPhone?: string\n): Partial<DBConversation> {\n  return {\n    business_id: conversation.businessId,\n    customer_phone: customerPhone || \"\",\n    customer_email: conversation.customerEmail || undefined,\n  }\n}\n\n// Convert App Message to DB Message\nfunction appMessageToDB(message: Partial<Message>): Partial<DBMessage> {\n  return {\n    conversation_id: message.conversationId,\n    sender_type: message.senderType,\n    sender_id: message.senderId || \"\",\n    content: message.text || null,\n    image_url: message.imageUrl || null,\n    status: message.status || \"sent\",\n    reply_to_id: message.replyToId || null,\n  }\n}\n\nexport const db = {\n  // Businesses\n  async getBusinessById(id: string): Promise<Business | null> {\n    const supabase = createClient()\n    const { data, error } = await supabase\n      .from(\"businesses\")\n      .select(\"id, email, password_hash, business_name, phone, address, business_logo, online, away_message, away_message_enabled, is_admin, created_at, updated_at\")\n      .eq(\"id\", id)\n      .maybeSingle() // Use maybeSingle() to handle missing businesses gracefully\n\n    if (error || !data) return null\n    return dbBusinessToApp(data as DBBusiness)\n  },\n\n  async getBusinessByEmail(email: string): Promise<Business | null> {\n    const supabase = createClient()\n    const { data, error } = await supabase\n      .from(\"businesses\")\n      .select(\"id, email, password_hash, business_name, phone, address, business_logo, online, away_message, away_message_enabled, is_admin, created_at, updated_at\")\n      .eq(\"email\", email)\n      .maybeSingle() // Use maybeSingle() to handle missing businesses gracefully\n\n    if (error || !data) return null\n    return dbBusinessToApp(data as DBBusiness)\n  },\n\n  async getBusinessByPhone(phone: string): Promise<Business | null> {\n    const supabase = createClient()\n    const { data, error } = await supabase\n      .from(\"businesses\")\n      .select(\"id, email, password_hash, business_name, phone, address, business_logo, online, away_message, away_message_enabled, is_admin, created_at, updated_at\")\n      .eq(\"phone\", phone)\n      .maybeSingle() // Use maybeSingle() to handle missing businesses gracefully\n\n    if (error || !data) return null\n    return dbBusinessToApp(data as DBBusiness)\n  },\n\n  async createBusiness(business: Business, passwordHash: string = \"\"): Promise<Business> {\n    const supabase = createClient()\n    const dbData: any = {\n      id: business.id,\n      email: business.email,\n      password_hash: passwordHash, // Empty for Supabase Auth, but required by schema\n      business_name: business.businessName || null,\n      phone: business.phone || null,\n      address: business.address || null,\n      business_logo: business.businessLogo || null,\n    }\n\n    const { data, error } = await supabase.from(\"businesses\").insert(dbData).select().single()\n\n    if (error) throw error\n    return dbBusinessToApp(data as DBBusiness)\n  },\n\n  async updateBusiness(id: string, updates: Partial<Business>): Promise<Business | null> {\n    const supabase = createClient()\n    const dbData: any = appBusinessToDB(updates)\n    // Make sure to include business_logo if it's being updated\n    if (updates.businessLogo !== undefined) {\n      dbData.business_logo = updates.businessLogo || null\n    }\n    \n    // Try to include online status if it's being updated\n    // If the column doesn't exist yet, we'll skip it and continue with other updates\n    if (updates.online !== undefined) {\n      // Check if online column exists by trying a test query first\n      // For now, we'll include it and let the error be caught if column doesn't exist\n      dbData.online = updates.online\n    }\n    \n    const { data, error } = await supabase\n      .from(\"businesses\")\n      .update(dbData)\n      .eq(\"id\", id)\n      .select()\n      .maybeSingle() // Use maybeSingle() to handle missing businesses gracefully\n\n    if (error) {\n      // If error is about missing 'online' column, try again without it\n      if (error.message?.includes(\"online\") && error.code === \"PGRST204\") {\n        console.warn(\"Online column not found, updating without online status. Please run migration 008_add_online_status.sql\")\n        delete dbData.online\n        const { data: retryData, error: retryError } = await supabase\n          .from(\"businesses\")\n          .update(dbData)\n          .eq(\"id\", id)\n          .select()\n          .maybeSingle() // Use maybeSingle() to handle missing businesses gracefully\n        \n        if (retryError) {\n          console.error(\"Error updating business:\", retryError)\n          throw new Error(retryError.message || \"Failed to update business\")\n        }\n        if (!retryData) {\n          throw new Error(\"No data returned from update\")\n        }\n        return dbBusinessToApp(retryData as DBBusiness)\n      }\n      \n      console.error(\"Error updating business:\", error)\n      throw new Error(error.message || \"Failed to update business\")\n    }\n    if (!data) {\n      throw new Error(\"No data returned from update\")\n    }\n    return dbBusinessToApp(data as DBBusiness)\n  },\n\n  // Conversations\n  async getConversationsByBusinessId(businessId: string): Promise<Conversation[]> {\n    const supabase = createClient()\n    const { data: conversations, error } = await supabase\n      .from(\"conversations\")\n      .select(\"id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned\")\n      .eq(\"business_id\", businessId)\n      .order(\"updated_at\", { ascending: false })\n      .limit(100) // Limit to prevent huge queries\n\n    if (error || !conversations || conversations.length === 0) {\n      monitorRequest(\"getConversationsByBusinessId\", [])\n      return []\n    }\n\n    const conversationIds = conversations.map((c) => c.id)\n    \n    // Optimized: Use a single query with window functions or batch queries\n    // Fetch last messages for all conversations in one optimized query\n    const lastMessagesQuery = supabase\n      .from(\"messages\")\n      .select(\"id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id\")\n      .in(\"conversation_id\", conversationIds)\n    \n    // Get the last message per conversation using a subquery approach\n    // For now, we'll batch the queries but limit to prevent N+1\n    const batchSize = 10 // Process 10 conversations at a time\n    const batches = []\n    for (let i = 0; i < conversationIds.length; i += batchSize) {\n      const batch = conversationIds.slice(i, i + batchSize)\n      batches.push(batch)\n    }\n    \n    // Fetch last messages and unread counts in parallel batches\n    const [lastMessagesResults, unreadCountsResults] = await Promise.all([\n      Promise.all(\n        batches.flatMap(batch =>\n          batch.map(async (conversationId) => {\n            const { data: messages } = await supabase\n              .from(\"messages\")\n              .select(\"id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id\")\n              .eq(\"conversation_id\", conversationId)\n              .order(\"created_at\", { ascending: false })\n              .limit(1)\n            \n            return { \n              conversationId, \n              lastMessage: messages && messages.length > 0 ? messages[0] as DBMessage : null \n            }\n          })\n        )\n      ),\n      // Batch unread count queries\n      Promise.all(\n        batches.flatMap(batch =>\n          batch.map(async (conversationId) => {\n            const { count } = await supabase\n              .from(\"messages\")\n              .select(\"id\", { count: \"exact\", head: true })\n              .eq(\"conversation_id\", conversationId)\n              .eq(\"sender_type\", \"customer\")\n              .in(\"status\", [\"sent\", \"delivered\"])\n            \n            return { \n              conversationId, \n              unreadCount: count || 0 \n            }\n          })\n        )\n      )\n    ])\n\n    // Create maps for quick lookup\n    const lastMessageMap = new Map<string, DBMessage>()\n    const unreadCountMap = new Map<string, number>()\n    \n    lastMessagesResults.forEach(({ conversationId, lastMessage }) => {\n      if (lastMessage) {\n        lastMessageMap.set(conversationId, lastMessage)\n      }\n    })\n    \n    unreadCountsResults.forEach(({ conversationId, unreadCount }) => {\n      unreadCountMap.set(conversationId, unreadCount)\n    })\n\n    // Convert to app format - only include last message, not all messages\n    const result = conversations.map((conv) => {\n      const lastMessage = lastMessageMap.get(conv.id)\n      const messages = lastMessage ? [lastMessage] : []\n      const conversation = dbConversationToApp(conv as DBConversation, messages)\n      // Add unread count to conversation\n      conversation.unreadCount = unreadCountMap.get(conv.id) || 0\n      return conversation\n    })\n    \n    monitorRequest(\"getConversationsByBusinessId\", result)\n    return result\n  },\n\n  async getConversationById(id: string): Promise<Conversation | null> {\n    const supabase = createClient()\n    const { data: conversation, error } = await supabase\n      .from(\"conversations\")\n      .select(\"id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned\")\n      .eq(\"id\", id)\n      .maybeSingle() // Use maybeSingle() to handle missing conversations gracefully\n\n    if (error || !conversation) return null\n\n    // Reduced initial message fetch to 25 most recent messages for performance\n    // Use selective fields instead of select(\"*\")\n    const { data: messages } = await supabase\n      .from(\"messages\")\n      .select(\"id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id\")\n      .eq(\"conversation_id\", id)\n      .order(\"created_at\", { ascending: false })\n      .limit(25)\n\n    // Reverse to get chronological order (oldest first)\n    const sortedMessages = messages ? [...messages].reverse() : []\n\n    return dbConversationToApp(conversation as DBConversation, (sortedMessages as DBMessage[]) || [])\n  },\n\n  // Paginated message loading for infinite scroll\n  async getMessagesPaginated(\n    conversationId: string,\n    beforeMessageId?: string,\n    limit: number = 25\n  ): Promise<Message[]> {\n    const supabase = createClient()\n    \n    let query = supabase\n      .from(\"messages\")\n      .select(\"id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id\")\n      .eq(\"conversation_id\", conversationId)\n      .order(\"created_at\", { ascending: false })\n      .limit(limit)\n\n    // If beforeMessageId is provided, fetch messages before that message\n    if (beforeMessageId) {\n      const { data: beforeMessage, error: beforeError } = await supabase\n        .from(\"messages\")\n        .select(\"created_at\")\n        .eq(\"id\", beforeMessageId)\n        .maybeSingle() // Use maybeSingle() instead of single() to handle 0 rows gracefully\n      \n      // Only apply filter if message exists and no error\n      if (!beforeError && beforeMessage) {\n        query = query.lt(\"created_at\", beforeMessage.created_at)\n      } else {\n        // If message not found, return empty array (no more messages to load)\n        monitorRequest(\"getMessagesPaginated\", [])\n        return []\n      }\n    }\n\n    const { data: messages, error } = await query\n\n    if (error || !messages) {\n      monitorRequest(\"getMessagesPaginated\", [])\n      return []\n    }\n\n    // Reverse to get chronological order (oldest first)\n    const sortedMessages = [...messages].reverse()\n\n    // Convert to app format\n    const result = sortedMessages.map((m) => ({\n      id: m.id,\n      conversationId: m.conversation_id,\n      senderType: m.sender_type,\n      senderId: m.sender_id,\n      text: m.content || undefined,\n      imageUrl: m.image_url || undefined,\n      status: (m.status || \"sent\") as \"sent\" | \"delivered\" | \"read\",\n      createdAt: m.created_at,\n      replyToId: m.reply_to_id || undefined,\n    }))\n    \n    monitorRequest(\"getMessagesPaginated\", result)\n    return result\n  },\n\n  async getConversationByBusinessAndEmail(\n    businessId: string,\n    customerEmail: string\n  ): Promise<Conversation | null> {\n    const supabase = createClient()\n    const { data: conversation, error } = await supabase\n      .from(\"conversations\")\n      .select(\"id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned\")\n      .eq(\"business_id\", businessId)\n      .eq(\"customer_email\", customerEmail)\n      .maybeSingle() // Use maybeSingle() to handle missing conversations gracefully\n\n    if (error || !conversation) return null\n\n    // Only fetch last 25 messages instead of all messages\n    const { data: messages } = await supabase\n      .from(\"messages\")\n      .select(\"id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id\")\n      .eq(\"conversation_id\", conversation.id)\n      .order(\"created_at\", { ascending: false })\n      .limit(25)\n\n    // Reverse to get chronological order (oldest first)\n    const sortedMessages = messages ? [...messages].reverse() : []\n\n    return dbConversationToApp(conversation as DBConversation, (sortedMessages as DBMessage[]) || [])\n  },\n\n  async createConversation(conversation: Conversation): Promise<Conversation> {\n    const supabase = createClient()\n    const dbData: any = {\n      id: conversation.id,\n      business_id: conversation.businessId,\n      customer_email: conversation.customerEmail,\n      customer_name: conversation.customerName || null,\n      customer_phone: null, // Phone is optional now\n    }\n\n    const { data, error } = await supabase.from(\"conversations\").insert(dbData).select().single()\n\n    if (error) {\n      // Create a properly formatted error with all Supabase error properties\n      const formattedError: any = new Error(error.message || \"Failed to create conversation\")\n      formattedError.code = error.code\n      formattedError.details = error.details\n      formattedError.hint = error.hint\n      formattedError.name = \"SupabaseError\"\n      // Preserve original error for debugging\n      formattedError.originalError = error\n      throw formattedError\n    }\n\n    // Create messages if any\n    if (conversation.messages && conversation.messages.length > 0) {\n      const messagesData = conversation.messages.map((m) => ({\n        id: m.id,\n        conversation_id: m.conversationId,\n        sender_type: m.senderType,\n        sender_id: m.senderId || conversation.businessId,\n        content: m.text || null,\n        image_url: m.imageUrl || null,\n      }))\n\n      await supabase.from(\"messages\").insert(messagesData)\n    }\n\n    return dbConversationToApp(data as DBConversation, [])\n  },\n\n  async updateConversation(id: string, updates: Partial<Conversation>): Promise<Conversation | null> {\n    const supabase = createClient()\n    const dbData: any = {}\n    if (updates.customerEmail !== undefined) {\n      dbData.customer_email = updates.customerEmail\n    }\n    if (updates.customerName !== undefined) {\n      dbData.customer_name = updates.customerName || null\n    }\n    if (updates.pinned !== undefined) {\n      dbData.pinned = updates.pinned\n    }\n\n    const { data, error } = await supabase\n      .from(\"conversations\")\n      .update(dbData)\n      .eq(\"id\", id)\n      .select(\"id, business_id, customer_phone, customer_name, customer_email, created_at, updated_at, pinned\")\n      .maybeSingle() // Use maybeSingle() to handle missing conversations gracefully\n\n    if (error || !data) return null\n\n    // Don't fetch all messages on update - just return conversation without messages\n    // Messages will be loaded separately via getConversationById or getMessagesPaginated\n    return dbConversationToApp(data as DBConversation, [])\n  },\n\n  async updateMessageStatus(id: string, status: \"sent\" | \"delivered\" | \"read\"): Promise<void> {\n    const supabase = createClient()\n    await supabase.from(\"messages\").update({ status }).eq(\"id\", id)\n  },\n\n  async markMessagesAsDelivered(conversationId: string, senderType: \"business\" | \"customer\"): Promise<void> {\n    const supabase = createClient()\n    // Mark all messages from the other sender as delivered\n    await supabase\n      .from(\"messages\")\n      .update({ status: \"delivered\" })\n      .eq(\"conversation_id\", conversationId)\n      .eq(\"sender_type\", senderType)\n      .in(\"status\", [\"sent\"])\n  },\n\n  async markMessagesAsRead(conversationId: string, senderType: \"business\" | \"customer\"): Promise<void> {\n    const supabase = createClient()\n    // Mark all messages from the other sender as read\n    await supabase\n      .from(\"messages\")\n      .update({ status: \"read\" })\n      .eq(\"conversation_id\", conversationId)\n      .eq(\"sender_type\", senderType)\n      .in(\"status\", [\"sent\", \"delivered\"])\n  },\n\n  async updateMessage(id: string, updates: { text?: string }): Promise<Message | null> {\n    const supabase = createClient()\n    const dbData: any = {}\n    if (updates.text !== undefined) {\n      dbData.content = updates.text\n    }\n\n    const { data, error } = await supabase\n      .from(\"messages\")\n      .update(dbData)\n      .eq(\"id\", id)\n      .select(\"id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id\")\n      .maybeSingle()\n\n    if (error || !data) return null\n\n    return {\n      id: data.id,\n      conversationId: data.conversation_id,\n      senderType: data.sender_type,\n      senderId: data.sender_id,\n      text: data.content || undefined,\n      imageUrl: data.image_url || undefined,\n      status: (data.status || \"sent\") as \"sent\" | \"delivered\" | \"read\",\n      createdAt: data.created_at,\n      replyToId: data.reply_to_id || undefined,\n    }\n  },\n\n  async deleteMessage(id: string): Promise<void> {\n    const supabase = createClient()\n    await supabase.from(\"messages\").delete().eq(\"id\", id)\n  },\n\n  // Messages\n  async createMessage(message: Message): Promise<Message> {\n    const supabase = createClient()\n    const dbData: any = {\n      id: message.id,\n      conversation_id: message.conversationId,\n      sender_type: message.senderType,\n      sender_id: message.senderId || \"\",\n      content: message.text || null,\n      image_url: message.imageUrl || null,\n      status: message.status || \"sent\",\n      reply_to_id: message.replyToId || null,\n    }\n\n    const { data, error } = await supabase\n      .from(\"messages\")\n      .insert(dbData)\n      .select(\"id, conversation_id, sender_type, sender_id, content, image_url, status, created_at, reply_to_id\")\n      .single()\n\n    if (error) throw error\n\n    // Update conversation's updated_at\n    await supabase\n      .from(\"conversations\")\n      .update({ updated_at: new Date().toISOString() })\n      .eq(\"id\", message.conversationId)\n\n    // If this is a customer message, trigger away message check (async, don't block)\n    if (message.senderType === \"customer\") {\n      // Get business ID from conversation\n      const { data: convData, error: convError } = await supabase\n        .from(\"conversations\")\n        .select(\"business_id\")\n        .eq(\"id\", message.conversationId)\n        .maybeSingle() // Use maybeSingle() to handle missing conversations gracefully\n      \n      if (!convError && convData?.business_id) {\n        // Send away message asynchronously (fire and forget - don't block message creation)\n        sendAwayMessageIfEnabled(message.conversationId, convData.business_id)\n          .catch((err) => console.error(\"Error sending away message:\", err))\n      }\n    }\n\n    return {\n      id: data.id,\n      conversationId: data.conversation_id,\n      senderType: data.sender_type,\n      senderId: data.sender_id,\n      text: data.content || undefined,\n      imageUrl: data.image_url || undefined,\n      status: (data.status || \"sent\") as \"sent\" | \"delivered\" | \"read\",\n      createdAt: data.created_at,\n      replyToId: data.reply_to_id || undefined,\n    }\n  },\n\n  async deleteConversation(id: string): Promise<void> {\n    const supabase = createClient()\n    const { error } = await supabase\n      .from(\"conversations\")\n      .delete()\n      .eq(\"id\", id)\n\n    if (error) throw error\n  },\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 731, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/auth.ts"],"sourcesContent":["import { createClient } from \"./supabase/client\"\nimport { db } from \"./supabase/db\"\nimport type { AuthUser, Business } from \"./types\"\n\nexport const auth = {\n  // Sign up with email and password\n  async signUp(email: string, password: string): Promise<{ user: AuthUser | null; error: Error | null }> {\n    try {\n      const supabase = createClient()\n\n      // Sign up with Supabase Auth\n      const { data: authData, error: authError } = await supabase.auth.signUp({\n        email,\n        password,\n      })\n\n      if (authError) {\n        return { user: null, error: authError as Error }\n      }\n\n      if (!authData.user) {\n        return { user: null, error: new Error(\"Failed to create user\") }\n      }\n\n      // Create business record in database\n      const business: Business = {\n        id: authData.user.id,\n        email,\n        phone: \"\",\n        businessName: \"\",\n        address: \"\",\n        online: false,\n        createdAt: new Date().toISOString(),\n      }\n\n      // Create business record in database (no password hash needed, Supabase handles auth)\n      try {\n        await db.createBusiness(business, \"\")\n      } catch (dbError) {\n        // If business creation fails, the auth user is still created\n        // This should be handled by a database trigger or cleanup job\n        return { user: null, error: new Error(\"Failed to create business profile\") }\n      }\n\n      const createdBusiness = await db.getBusinessById(authData.user.id)\n      if (!createdBusiness) {\n        return { user: null, error: new Error(\"Failed to retrieve business profile\") }\n      }\n\n      const authUser: AuthUser = {\n        id: authData.user.id,\n        email,\n        business: createdBusiness,\n      }\n\n      return { user: authUser, error: null }\n    } catch (error) {\n      return { user: null, error: error as Error }\n    }\n  },\n\n  // Sign in with email and password\n  async signIn(email: string, password: string): Promise<{ user: AuthUser | null; error: Error | null }> {\n    try {\n      const supabase = createClient()\n\n      const { data: authData, error: authError } = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      })\n\n      if (authError || !authData.user) {\n        return { user: null, error: authError as Error || new Error(\"Invalid credentials\") }\n      }\n\n      // Get business data\n      const business = await db.getBusinessById(authData.user.id)\n\n      if (!business) {\n        return { user: null, error: new Error(\"Business profile not found\") }\n      }\n\n      // Business is always online - no need to update status\n      const updatedBusiness = await db.getBusinessById(authData.user.id)\n\n      const authUser: AuthUser = {\n        id: authData.user.id,\n        email: authData.user.email!,\n        business: updatedBusiness || business,\n      }\n\n      return { user: authUser, error: null }\n    } catch (error) {\n      return { user: null, error: error as Error }\n    }\n  },\n\n  // Sign out\n  async signOut(): Promise<{ error: Error | null }> {\n    try {\n      const supabase = createClient()\n      \n      // Business is always online - no need to update status\n      const { error } = await supabase.auth.signOut()\n      return { error: error as Error | null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  },\n\n  // Get current user\n  async getCurrentUser(): Promise<AuthUser | null> {\n    try {\n      const supabase = createClient()\n      const {\n        data: { user: authUser },\n        error,\n      } = await supabase.auth.getUser()\n\n      if (error || !authUser) {\n        return null\n      }\n\n      const business = await db.getBusinessById(authUser.id)\n\n      if (!business) {\n        return null\n      }\n\n      return {\n        id: authUser.id,\n        email: authUser.email!,\n        business,\n      }\n    } catch (error) {\n      return null\n    }\n  },\n\n  // Get session\n  async getSession() {\n    const supabase = createClient()\n    return await supabase.auth.getSession()\n  },\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 891, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/indexeddb-cache.ts"],"sourcesContent":["\"use client\"\n\nimport type { Message, Conversation } from \"./types\"\n\nconst DB_NAME = \"leenk_cache\"\nconst DB_VERSION = 1\nconst MESSAGES_STORE = \"messages\"\nconst CONVERSATIONS_STORE = \"conversations\"\nconst METADATA_STORE = \"metadata\"\n\ninterface DBMetadata {\n  key: string\n  value: string | number\n}\n\n// Initialize IndexedDB\nasync function openDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION)\n\n    request.onerror = () => reject(request.error)\n    request.onsuccess = () => resolve(request.result)\n\n    request.onupgradeneeded = (event) => {\n      const db = (event.target as IDBOpenDBRequest).result\n\n      // Messages store - indexed by conversationId and createdAt\n      if (!db.objectStoreNames.contains(MESSAGES_STORE)) {\n        const messagesStore = db.createObjectStore(MESSAGES_STORE, { keyPath: \"id\" })\n        messagesStore.createIndex(\"conversationId\", \"conversationId\", { unique: false })\n        messagesStore.createIndex(\"createdAt\", \"createdAt\", { unique: false })\n        messagesStore.createIndex(\"conversation_created\", [\"conversationId\", \"createdAt\"], { unique: false })\n      }\n\n      // Conversations store\n      if (!db.objectStoreNames.contains(CONVERSATIONS_STORE)) {\n        const conversationsStore = db.createObjectStore(CONVERSATIONS_STORE, { keyPath: \"id\" })\n        conversationsStore.createIndex(\"businessId\", \"businessId\", { unique: false })\n        conversationsStore.createIndex(\"updatedAt\", \"lastMessageAt\", { unique: false })\n      }\n\n      // Metadata store for cache timestamps\n      if (!db.objectStoreNames.contains(METADATA_STORE)) {\n        const metadataStore = db.createObjectStore(METADATA_STORE, { keyPath: \"key\" })\n      }\n    }\n  })\n}\n\n// Messages Cache\nexport const messageCache = {\n  // Save messages to cache\n  async saveMessages(conversationId: string, messages: Message[]): Promise<void> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([MESSAGES_STORE], \"readwrite\")\n      const store = transaction.objectStore(MESSAGES_STORE)\n\n      // Save each message\n      for (const message of messages) {\n        await new Promise<void>((resolve, reject) => {\n          const request = store.put(message)\n          request.onsuccess = () => resolve()\n          request.onerror = () => reject(request.error)\n        })\n      }\n\n      // Update cache timestamp\n      await this.updateCacheTimestamp(conversationId)\n    } catch (error) {\n      console.error(\"Error saving messages to cache:\", error)\n      // Don't throw - caching is optional\n    }\n  },\n\n  // Get messages from cache\n  async getMessages(conversationId: string, limit?: number): Promise<Message[]> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([MESSAGES_STORE], \"readonly\")\n      const store = transaction.objectStore(MESSAGES_STORE)\n      const index = store.index(\"conversation_created\")\n\n      return new Promise((resolve, reject) => {\n        const messages: Message[] = []\n        const request = index.openCursor(\n          IDBKeyRange.bound([conversationId, \"\"], [conversationId, \"\\uffff\"])\n        )\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result\n          if (cursor) {\n            messages.push(cursor.value as Message)\n            if (!limit || messages.length < limit) {\n              cursor.continue()\n            } else {\n              resolve(messages.sort((a, b) => \n                new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n              ))\n            }\n          } else {\n            resolve(messages.sort((a, b) => \n              new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()\n            ))\n          }\n        }\n\n        request.onerror = () => reject(request.error)\n      })\n    } catch (error) {\n      console.error(\"Error getting messages from cache:\", error)\n      return []\n    }\n  },\n\n  // Get oldest message timestamp for pagination\n  async getOldestMessageTimestamp(conversationId: string): Promise<string | null> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([MESSAGES_STORE], \"readonly\")\n      const store = transaction.objectStore(MESSAGES_STORE)\n      const index = store.index(\"conversation_created\")\n\n      return new Promise((resolve, reject) => {\n        const request = index.openCursor(\n          IDBKeyRange.bound([conversationId, \"\"], [conversationId, \"\\uffff\"]),\n          \"prev\" // Reverse order to get oldest first\n        )\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result\n          if (cursor) {\n            resolve((cursor.value as Message).createdAt)\n          } else {\n            resolve(null)\n          }\n        }\n\n        request.onerror = () => reject(request.error)\n      })\n    } catch (error) {\n      console.error(\"Error getting oldest message timestamp:\", error)\n      return null\n    }\n  },\n\n  // Clear messages for a conversation\n  async clearMessages(conversationId: string): Promise<void> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([MESSAGES_STORE], \"readwrite\")\n      const store = transaction.objectStore(MESSAGES_STORE)\n      const index = store.index(\"conversationId\")\n\n      return new Promise((resolve, reject) => {\n        const request = index.openCursor(IDBKeyRange.only(conversationId))\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result\n          if (cursor) {\n            cursor.delete()\n            cursor.continue()\n          } else {\n            resolve()\n          }\n        }\n\n        request.onerror = () => reject(request.error)\n      })\n    } catch (error) {\n      console.error(\"Error clearing messages from cache:\", error)\n    }\n  },\n\n  // Update cache timestamp\n  async updateCacheTimestamp(conversationId: string): Promise<void> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([METADATA_STORE], \"readwrite\")\n      const store = transaction.objectStore(METADATA_STORE)\n\n      await new Promise<void>((resolve, reject) => {\n        const request = store.put({\n          key: `messages_${conversationId}`,\n          value: Date.now(),\n        })\n        request.onsuccess = () => resolve()\n        request.onerror = () => reject(request.error)\n      })\n    } catch (error) {\n      console.error(\"Error updating cache timestamp:\", error)\n    }\n  },\n\n  // Check if cache is fresh (less than 5 minutes old)\n  async isCacheFresh(conversationId: string): Promise<boolean> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([METADATA_STORE], \"readonly\")\n      const store = transaction.objectStore(METADATA_STORE)\n\n      return new Promise((resolve, reject) => {\n        const request = store.get(`messages_${conversationId}`)\n\n        request.onsuccess = () => {\n          const result = request.result as DBMetadata | undefined\n          if (!result) {\n            resolve(false)\n            return\n          }\n\n          const cacheAge = Date.now() - (result.value as number)\n          resolve(cacheAge < 5 * 60 * 1000) // 5 minutes\n        }\n\n        request.onerror = () => reject(request.error)\n      })\n    } catch (error) {\n      console.error(\"Error checking cache freshness:\", error)\n      return false\n    }\n  },\n}\n\n// Conversations Cache\nexport const conversationCache = {\n  // Save conversations to cache\n  async saveConversations(conversations: Conversation[]): Promise<void> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([CONVERSATIONS_STORE], \"readwrite\")\n      const store = transaction.objectStore(CONVERSATIONS_STORE)\n\n      for (const conversation of conversations) {\n        await new Promise<void>((resolve, reject) => {\n          const request = store.put(conversation)\n          request.onsuccess = () => resolve()\n          request.onerror = () => reject(request.error)\n        })\n      }\n\n      // Update cache timestamp\n      await this.updateCacheTimestamp()\n    } catch (error) {\n      console.error(\"Error saving conversations to cache:\", error)\n    }\n  },\n\n  // Get conversations from cache\n  async getConversations(businessId: string): Promise<Conversation[]> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([CONVERSATIONS_STORE], \"readonly\")\n      const store = transaction.objectStore(CONVERSATIONS_STORE)\n      const index = store.index(\"businessId\")\n\n      return new Promise((resolve, reject) => {\n        const conversations: Conversation[] = []\n        const request = index.openCursor(IDBKeyRange.only(businessId))\n\n        request.onsuccess = (event) => {\n          const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result\n          if (cursor) {\n            conversations.push(cursor.value as Conversation)\n            cursor.continue()\n          } else {\n            resolve(conversations.sort((a, b) => \n              new Date(b.lastMessageAt).getTime() - new Date(a.lastMessageAt).getTime()\n            ))\n          }\n        }\n\n        request.onerror = () => reject(request.error)\n      })\n    } catch (error) {\n      console.error(\"Error getting conversations from cache:\", error)\n      return []\n    }\n  },\n\n  // Update cache timestamp\n  async updateCacheTimestamp(): Promise<void> {\n    try {\n      const db = await openDB()\n      const transaction = db.transaction([METADATA_STORE], \"readwrite\")\n      const store = transaction.objectStore(METADATA_STORE)\n\n      await new Promise<void>((resolve, reject) => {\n        const request = store.put({\n          key: \"conversations_timestamp\",\n          value: Date.now(),\n        })\n        request.onsuccess = () => resolve()\n        request.onerror = () => reject(request.error)\n      })\n    } catch (error) {\n      console.error(\"Error updating cache timestamp:\", error)\n    }\n  },\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;AAIA,MAAM,UAAU;AAChB,MAAM,aAAa;AACnB,MAAM,iBAAiB;AACvB,MAAM,sBAAsB;AAC5B,MAAM,iBAAiB;AAOvB,uBAAuB;AACvB,eAAe;IACb,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,UAAU,UAAU,IAAI,CAAC,SAAS;QAExC,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;QAC5C,QAAQ,SAAS,GAAG,IAAM,QAAQ,QAAQ,MAAM;QAEhD,QAAQ,eAAe,GAAG,CAAC;YACzB,MAAM,KAAK,AAAC,MAAM,MAAM,CAAsB,MAAM;YAEpD,2DAA2D;YAC3D,IAAI,CAAC,GAAG,gBAAgB,CAAC,QAAQ,CAAC,iBAAiB;gBACjD,MAAM,gBAAgB,GAAG,iBAAiB,CAAC,gBAAgB;oBAAE,SAAS;gBAAK;gBAC3E,cAAc,WAAW,CAAC,kBAAkB,kBAAkB;oBAAE,QAAQ;gBAAM;gBAC9E,cAAc,WAAW,CAAC,aAAa,aAAa;oBAAE,QAAQ;gBAAM;gBACpE,cAAc,WAAW,CAAC,wBAAwB;oBAAC;oBAAkB;iBAAY,EAAE;oBAAE,QAAQ;gBAAM;YACrG;YAEA,sBAAsB;YACtB,IAAI,CAAC,GAAG,gBAAgB,CAAC,QAAQ,CAAC,sBAAsB;gBACtD,MAAM,qBAAqB,GAAG,iBAAiB,CAAC,qBAAqB;oBAAE,SAAS;gBAAK;gBACrF,mBAAmB,WAAW,CAAC,cAAc,cAAc;oBAAE,QAAQ;gBAAM;gBAC3E,mBAAmB,WAAW,CAAC,aAAa,iBAAiB;oBAAE,QAAQ;gBAAM;YAC/E;YAEA,sCAAsC;YACtC,IAAI,CAAC,GAAG,gBAAgB,CAAC,QAAQ,CAAC,iBAAiB;gBACjD,MAAM,gBAAgB,GAAG,iBAAiB,CAAC,gBAAgB;oBAAE,SAAS;gBAAM;YAC9E;QACF;IACF;AACF;AAGO,MAAM,eAAe;IAC1B,yBAAyB;IACzB,MAAM,cAAa,cAAsB,EAAE,QAAmB;QAC5D,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAe,EAAE;YACrD,MAAM,QAAQ,YAAY,WAAW,CAAC;YAEtC,oBAAoB;YACpB,KAAK,MAAM,WAAW,SAAU;gBAC9B,MAAM,IAAI,QAAc,CAAC,SAAS;oBAChC,MAAM,UAAU,MAAM,GAAG,CAAC;oBAC1B,QAAQ,SAAS,GAAG,IAAM;oBAC1B,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;gBAC9C;YACF;YAEA,yBAAyB;YACzB,MAAM,IAAI,CAAC,oBAAoB,CAAC;QAClC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mCAAmC;QACjD,oCAAoC;QACtC;IACF;IAEA,0BAA0B;IAC1B,MAAM,aAAY,cAAsB,EAAE,KAAc;QACtD,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAe,EAAE;YACrD,MAAM,QAAQ,YAAY,WAAW,CAAC;YACtC,MAAM,QAAQ,MAAM,KAAK,CAAC;YAE1B,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,MAAM,WAAsB,EAAE;gBAC9B,MAAM,UAAU,MAAM,UAAU,CAC9B,YAAY,KAAK,CAAC;oBAAC;oBAAgB;iBAAG,EAAE;oBAAC;oBAAgB;iBAAS;gBAGpE,QAAQ,SAAS,GAAG,CAAC;oBACnB,MAAM,SAAS,AAAC,MAAM,MAAM,CAAoC,MAAM;oBACtE,IAAI,QAAQ;wBACV,SAAS,IAAI,CAAC,OAAO,KAAK;wBAC1B,IAAI,CAAC,SAAS,SAAS,MAAM,GAAG,OAAO;4BACrC,OAAO,QAAQ;wBACjB,OAAO;4BACL,QAAQ,SAAS,IAAI,CAAC,CAAC,GAAG,IACxB,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO;wBAEnE;oBACF,OAAO;wBACL,QAAQ,SAAS,IAAI,CAAC,CAAC,GAAG,IACxB,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO;oBAEnE;gBACF;gBAEA,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;YAC9C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sCAAsC;YACpD,OAAO,EAAE;QACX;IACF;IAEA,8CAA8C;IAC9C,MAAM,2BAA0B,cAAsB;QACpD,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAe,EAAE;YACrD,MAAM,QAAQ,YAAY,WAAW,CAAC;YACtC,MAAM,QAAQ,MAAM,KAAK,CAAC;YAE1B,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,MAAM,UAAU,MAAM,UAAU,CAC9B,YAAY,KAAK,CAAC;oBAAC;oBAAgB;iBAAG,EAAE;oBAAC;oBAAgB;iBAAS,GAClE,OAAO,oCAAoC;;gBAG7C,QAAQ,SAAS,GAAG,CAAC;oBACnB,MAAM,SAAS,AAAC,MAAM,MAAM,CAAoC,MAAM;oBACtE,IAAI,QAAQ;wBACV,QAAQ,AAAC,OAAO,KAAK,CAAa,SAAS;oBAC7C,OAAO;wBACL,QAAQ;oBACV;gBACF;gBAEA,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;YAC9C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2CAA2C;YACzD,OAAO;QACT;IACF;IAEA,oCAAoC;IACpC,MAAM,eAAc,cAAsB;QACxC,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAe,EAAE;YACrD,MAAM,QAAQ,YAAY,WAAW,CAAC;YACtC,MAAM,QAAQ,MAAM,KAAK,CAAC;YAE1B,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,MAAM,UAAU,MAAM,UAAU,CAAC,YAAY,IAAI,CAAC;gBAElD,QAAQ,SAAS,GAAG,CAAC;oBACnB,MAAM,SAAS,AAAC,MAAM,MAAM,CAAoC,MAAM;oBACtE,IAAI,QAAQ;wBACV,OAAO,MAAM;wBACb,OAAO,QAAQ;oBACjB,OAAO;wBACL;oBACF;gBACF;gBAEA,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;YAC9C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,uCAAuC;QACvD;IACF;IAEA,yBAAyB;IACzB,MAAM,sBAAqB,cAAsB;QAC/C,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAe,EAAE;YACrD,MAAM,QAAQ,YAAY,WAAW,CAAC;YAEtC,MAAM,IAAI,QAAc,CAAC,SAAS;gBAChC,MAAM,UAAU,MAAM,GAAG,CAAC;oBACxB,KAAK,CAAC,SAAS,EAAE,gBAAgB;oBACjC,OAAO,KAAK,GAAG;gBACjB;gBACA,QAAQ,SAAS,GAAG,IAAM;gBAC1B,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;YAC9C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mCAAmC;QACnD;IACF;IAEA,oDAAoD;IACpD,MAAM,cAAa,cAAsB;QACvC,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAe,EAAE;YACrD,MAAM,QAAQ,YAAY,WAAW,CAAC;YAEtC,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,MAAM,UAAU,MAAM,GAAG,CAAC,CAAC,SAAS,EAAE,gBAAgB;gBAEtD,QAAQ,SAAS,GAAG;oBAClB,MAAM,SAAS,QAAQ,MAAM;oBAC7B,IAAI,CAAC,QAAQ;wBACX,QAAQ;wBACR;oBACF;oBAEA,MAAM,WAAW,KAAK,GAAG,KAAM,OAAO,KAAK;oBAC3C,QAAQ,WAAW,IAAI,KAAK,OAAM,YAAY;gBAChD;gBAEA,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;YAC9C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mCAAmC;YACjD,OAAO;QACT;IACF;AACF;AAGO,MAAM,oBAAoB;IAC/B,8BAA8B;IAC9B,MAAM,mBAAkB,aAA6B;QACnD,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAoB,EAAE;YAC1D,MAAM,QAAQ,YAAY,WAAW,CAAC;YAEtC,KAAK,MAAM,gBAAgB,cAAe;gBACxC,MAAM,IAAI,QAAc,CAAC,SAAS;oBAChC,MAAM,UAAU,MAAM,GAAG,CAAC;oBAC1B,QAAQ,SAAS,GAAG,IAAM;oBAC1B,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;gBAC9C;YACF;YAEA,yBAAyB;YACzB,MAAM,IAAI,CAAC,oBAAoB;QACjC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wCAAwC;QACxD;IACF;IAEA,+BAA+B;IAC/B,MAAM,kBAAiB,UAAkB;QACvC,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAoB,EAAE;YAC1D,MAAM,QAAQ,YAAY,WAAW,CAAC;YACtC,MAAM,QAAQ,MAAM,KAAK,CAAC;YAE1B,OAAO,IAAI,QAAQ,CAAC,SAAS;gBAC3B,MAAM,gBAAgC,EAAE;gBACxC,MAAM,UAAU,MAAM,UAAU,CAAC,YAAY,IAAI,CAAC;gBAElD,QAAQ,SAAS,GAAG,CAAC;oBACnB,MAAM,SAAS,AAAC,MAAM,MAAM,CAAoC,MAAM;oBACtE,IAAI,QAAQ;wBACV,cAAc,IAAI,CAAC,OAAO,KAAK;wBAC/B,OAAO,QAAQ;oBACjB,OAAO;wBACL,QAAQ,cAAc,IAAI,CAAC,CAAC,GAAG,IAC7B,IAAI,KAAK,EAAE,aAAa,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,aAAa,EAAE,OAAO;oBAE3E;gBACF;gBAEA,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;YAC9C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2CAA2C;YACzD,OAAO,EAAE;QACX;IACF;IAEA,yBAAyB;IACzB,MAAM;QACJ,IAAI;YACF,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc,GAAG,WAAW,CAAC;gBAAC;aAAe,EAAE;YACrD,MAAM,QAAQ,YAAY,WAAW,CAAC;YAEtC,MAAM,IAAI,QAAc,CAAC,SAAS;gBAChC,MAAM,UAAU,MAAM,GAAG,CAAC;oBACxB,KAAK;oBACL,OAAO,KAAK,GAAG;gBACjB;gBACA,QAAQ,SAAS,GAAG,IAAM;gBAC1B,QAAQ,OAAO,GAAG,IAAM,OAAO,QAAQ,KAAK;YAC9C;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mCAAmC;QACnD;IACF;AACF"}},
    {"offset": {"line": 1193, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/storage.ts"],"sourcesContent":["import type { Business, Conversation, AuthUser, Message } from \"./types\"\nimport { db } from \"./supabase/db\"\nimport { auth } from \"./auth\"\nimport { messageCache, conversationCache } from \"./indexeddb-cache\"\nimport { monitorRequest } from \"./egress-monitor\"\n\nexport const storage = {\n  // Businesses\n  getAllBusinesses: async (): Promise<Business[]> => {\n    // Note: This is not ideal for Supabase as it would return all businesses\n    // In a real app, you'd only get businesses the user has access to\n    // For now, return empty array - this method might not be needed\n    return []\n  },\n\n  getBusinessByPhone: async (phone: string): Promise<Business | null> => {\n    return await db.getBusinessByPhone(phone)\n  },\n\n  getBusinessById: async (id: string): Promise<Business | null> => {\n    return await db.getBusinessById(id)\n  },\n\n  createBusiness: async (business: Business): Promise<void> => {\n    // Note: This should typically be called through auth.signUp\n    // Password hash would be handled by Supabase Auth\n    await db.createBusiness(business, \"\")\n  },\n\n  updateBusiness: async (id: string, updates: Partial<Business>): Promise<Business> => {\n    const result = await db.updateBusiness(id, updates)\n    if (!result) {\n      throw new Error(\"Failed to update business\")\n    }\n    return result\n  },\n\n  // Conversations\n  getConversationsByBusinessId: async (businessId: string): Promise<Conversation[]> => {\n    // Cache-first strategy for faster initial load\n    // Return cached data immediately, then update in background\n    try {\n      // Try cache first for instant display\n      const cached = await conversationCache.getConversations(businessId)\n      \n      // Fetch from server in background (don't await)\n      db.getConversationsByBusinessId(businessId)\n        .then((conversations) => {\n          // Update cache with fresh data\n          conversationCache.saveConversations(conversations).catch(console.error)\n          monitorRequest(\"getConversationsByBusinessId\", conversations)\n        })\n        .catch((error) => {\n          console.error(\"Error fetching conversations from server:\", error)\n        })\n      \n      // Return cached data immediately if available\n      if (cached.length > 0) {\n        return cached\n      }\n      \n      // If no cache, wait for server fetch\n      const conversations = await db.getConversationsByBusinessId(businessId)\n      conversationCache.saveConversations(conversations).catch(console.error)\n      monitorRequest(\"getConversationsByBusinessId\", conversations)\n      return conversations\n    } catch (error) {\n      console.error(\"Error fetching conversations:\", error)\n      // If server fetch fails, try cache as fallback\n      const cached = await conversationCache.getConversations(businessId)\n      if (cached.length > 0) {\n        console.log(\"Using cached conversations as fallback\")\n        return cached\n      }\n      // If both fail, return empty array\n      return []\n    }\n  },\n\n  getConversationById: async (id: string): Promise<Conversation | null> => {\n    // Cache-first strategy for faster initial load\n    try {\n      // Try to get cached messages first for instant display\n      const cachedMessages = await messageCache.getMessages(id, 25)\n      const isCacheFresh = await messageCache.isCacheFresh(id)\n      \n      // If we have fresh cached messages, return them immediately while fetching fresh data\n      if (cachedMessages.length > 0 && isCacheFresh) {\n        // Fetch fresh data in background\n        db.getConversationById(id)\n          .then((conversation) => {\n            if (conversation) {\n              messageCache.saveMessages(id, conversation.messages).catch(console.error)\n              monitorRequest(\"getConversationById\", conversation)\n            }\n          })\n          .catch(console.error)\n        \n        // Still need conversation metadata - fetch it (this is fast)\n        const conversation = await db.getConversationById(id)\n        if (conversation) {\n          return {\n            ...conversation,\n            messages: cachedMessages,\n          }\n        }\n      }\n      \n      // If no cache or cache is stale, fetch from server\n      const conversation = await db.getConversationById(id)\n      \n      if (conversation) {\n        // Save to cache for next time (async, don't block)\n        messageCache.saveMessages(id, conversation.messages).catch(console.error)\n        monitorRequest(\"getConversationById\", conversation)\n      }\n      \n      return conversation\n    } catch (error) {\n      console.error(\"Error fetching conversation:\", error)\n      // If server fetch fails, try cache as fallback\n      const cachedMessages = await messageCache.getMessages(id, 25)\n      if (cachedMessages.length > 0) {\n        console.log(\"Using cached messages as fallback\")\n        // Still need to fetch conversation metadata\n        try {\n          const conversation = await db.getConversationById(id)\n          if (conversation) {\n            return {\n              ...conversation,\n              messages: cachedMessages,\n            }\n          }\n        } catch (err) {\n          console.error(\"Error fetching conversation metadata:\", err)\n        }\n      }\n      // If both fail, return null\n      return null\n    }\n  },\n\n  getMessagesPaginated: async (\n    conversationId: string,\n    beforeMessageId?: string,\n    limit: number = 25\n  ): Promise<Message[]> => {\n    // For pagination, always fetch from server (cache is for initial load)\n    const messages = await db.getMessagesPaginated(conversationId, beforeMessageId, limit)\n    \n    // Save to cache\n    if (messages.length > 0) {\n      await messageCache.saveMessages(conversationId, messages)\n    }\n    \n    monitorRequest(\"getMessagesPaginated\", messages)\n    return messages\n  },\n\n  createConversation: async (conversation: Conversation): Promise<void> => {\n    if (!conversation.customerEmail) {\n      throw new Error(\"customerEmail is required to create a conversation\")\n    }\n    try {\n      await db.createConversation(conversation)\n    } catch (error: any) {\n      // Re-throw with better error information\n      const enhancedError = new Error(error?.message || \"Failed to create conversation\")\n      ;(enhancedError as any).code = error?.code\n      ;(enhancedError as any).details = error?.details\n      ;(enhancedError as any).hint = error?.hint\n      throw enhancedError\n    }\n  },\n\n  updateConversation: async (id: string, updates: Partial<Conversation>): Promise<Conversation | null> => {\n    return await db.updateConversation(id, updates)\n  },\n\n  deleteConversation: async (id: string): Promise<void> => {\n    await db.deleteConversation(id)\n  },\n\n  // Auth\n  getAuth: async (): Promise<AuthUser | null> => {\n    return await auth.getCurrentUser()\n  },\n\n  setAuth: async (user: AuthUser): Promise<void> => {\n    // Auth is managed by Supabase sessions\n    // This method is kept for compatibility but doesn't need to do anything\n    // The session is automatically managed by Supabase\n  },\n\n  clearAuth: async (): Promise<void> => {\n    await auth.signOut()\n  },\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1370, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/lib/hooks/use-auth.ts"],"sourcesContent":["import useSWR from \"swr\"\nimport { storage } from \"../storage\"\nimport type { AuthUser } from \"../types\"\n\n// Fetcher function for SWR\nconst authFetcher = async (): Promise<AuthUser | null> => {\n  return await storage.getAuth()\n}\n\nexport function useAuth() {\n  const { data, error, isLoading, mutate } = useSWR<AuthUser | null>(\n    \"auth\",\n    authFetcher,\n    {\n      revalidateOnFocus: false,\n      revalidateOnReconnect: true,\n      dedupingInterval: 5000,\n      refreshInterval: 10000, // Refresh every 10 seconds to update online status\n      // Don't set fallbackData - let it be undefined initially\n    }\n  )\n\n  return {\n    user: data,\n    isLoading,\n    error,\n    mutate, // For manual cache updates\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGA,2BAA2B;AAC3B,MAAM,cAAc;IAClB,OAAO,MAAM,yHAAO,CAAC,OAAO;AAC9B;AAEO,SAAS;IACd,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,IAAA,+OAAM,EAC/C,QACA,aACA;QACE,mBAAmB;QACnB,uBAAuB;QACvB,kBAAkB;QAClB,iBAAiB;IAEnB;IAGF,OAAO;QACL,MAAM;QACN;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 1400, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/leenk/app/onboarding/page.tsx"],"sourcesContent":["\"use client\"\n\nimport type React from \"react\"\n\nimport { useState, useEffect } from \"react\"\nimport { useRouter } from \"next/navigation\"\nimport { Button } from \"@/components/ui/button\"\nimport { motion } from \"framer-motion\"\nimport { storage } from \"@/lib/storage\"\nimport { useAuth } from \"@/lib/hooks/use-auth\"\nimport type { AuthUser } from \"@/lib/types\"\nimport Image from \"next/image\"\nimport { FaBuilding, FaMapMarkerAlt, FaSpinner, FaExclamationCircle } from \"react-icons/fa\"\nimport { FiPhone } from \"react-icons/fi\"\n\n// Helper function to check if onboarding is complete\nfunction isOnboardingComplete(business: AuthUser[\"business\"] | null | undefined): boolean {\n  if (!business) return false\n  return !!(business.businessName && business.phone && business.address)\n}\n\nexport default function OnboardingPage() {\n  const router = useRouter()\n  const { user, isLoading: authLoading, mutate: mutateAuth } = useAuth()\n  const [businessName, setBusinessName] = useState(\"\")\n  const [phone, setPhone] = useState(\"\")\n  const [address, setAddress] = useState(\"\")\n  const [error, setError] = useState(\"\")\n  const [loading, setLoading] = useState(false)\n  const [initialized, setInitialized] = useState(false)\n\n  useEffect(() => {\n    if (!authLoading && !user) {\n        router.push(\"/login\")\n        return\n      }\n\n    if (!authLoading && user) {\n      // If onboarding is already complete, redirect to dashboard\n      if (isOnboardingComplete(user.business)) {\n        router.push(\"/dashboard\")\n        return\n      }\n\n      // Pre-fill form with existing data if available\n      if (user.business && !initialized) {\n        setBusinessName(user.business.businessName || \"\")\n        setPhone(user.business.phone || \"\")\n        setAddress(user.business.address || \"\")\n        setInitialized(true)\n    }\n    }\n  }, [authLoading, user, router, initialized])\n\n  const handleComplete = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setError(\"\")\n    setLoading(true)\n\n    try {\n      // Validate all fields\n      if (!businessName.trim()) {\n        setError(\"Business name is required\")\n        setLoading(false)\n        return\n      }\n\n      if (!phone.trim()) {\n        setError(\"Phone number is required\")\n        setLoading(false)\n        return\n      }\n\n      if (!address.trim()) {\n        setError(\"Address is required\")\n        setLoading(false)\n        return\n      }\n\n      // Validate phone format (basic check)\n      const phoneRegex = /^[\\+]?[(]?[0-9]{1,4}[)]?[-\\s\\.]?[(]?[0-9]{1,4}[)]?[-\\s\\.]?[0-9]{1,9}$/\n      if (!phoneRegex.test(phone.trim())) {\n        setError(\"Please enter a valid phone number\")\n        setLoading(false)\n        return\n      }\n\n      if (!user?.business) {\n        setError(\"User account not found. Please try logging in again.\")\n        setLoading(false)\n        return\n      }\n\n      // Check if phone is already in use by another business\n      const existingBusiness = await storage.getBusinessByPhone(phone.trim())\n      if (existingBusiness && existingBusiness.id !== user.id) {\n        setError(\"This phone number is already in use by another business\")\n        setLoading(false)\n        return\n      }\n\n      // Update business with all required information\n      console.log(\"Updating business with:\", {\n        businessName: businessName.trim(),\n        phone: phone.trim(),\n        address: address.trim(),\n      })\n\n      const updatedBusiness = await storage.updateBusiness(user.business.id, {\n        businessName: businessName.trim(),\n        phone: phone.trim(),\n        address: address.trim(),\n      })\n\n      console.log(\"Update result:\", updatedBusiness)\n\n      if (!updatedBusiness) {\n        throw new Error(\"Failed to update business details. Please try again.\")\n      }\n\n      // Verify the update was successful by checking the returned data\n      if (!updatedBusiness.businessName || !updatedBusiness.phone || !updatedBusiness.address) {\n        console.error(\"Update verification failed:\", updatedBusiness)\n        throw new Error(\"Business details were not saved correctly. Please try again.\")\n      }\n\n      console.log(\"Update verified successfully, refreshing cache...\")\n\n      // Invalidate and refresh auth cache to get updated business data\n      await mutateAuth()\n\n      // Wait a moment for the cache to update\n      await new Promise(resolve => setTimeout(resolve, 200))\n      \n      // Verify the cache was updated before redirecting\n      const refreshedUser = await storage.getAuth()\n      console.log(\"Refreshed user after update:\", refreshedUser)\n      \n      if (refreshedUser && isOnboardingComplete(refreshedUser.business)) {\n        console.log(\"Onboarding complete, redirecting to dashboard\")\n        router.push(\"/dashboard\")\n      } else {\n        console.warn(\"Onboarding not complete after update, forcing refresh...\")\n        // Force another refresh\n        await mutateAuth()\n        // Redirect anyway - the dashboard will handle the check\n      router.push(\"/dashboard\")\n      }\n    } catch (err) {\n      console.error(\"Error completing onboarding:\", err)\n      setError(err instanceof Error ? err.message : \"Failed to complete setup. Please try again.\")\n      setLoading(false)\n    }\n  }\n\n  if (authLoading || !initialized) {\n    return (\n      <main className=\"min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 via-white to-slate-100 dark:from-slate-950 dark:via-slate-900 dark:to-slate-800\">\n        <div className=\"flex items-center gap-2 text-slate-600 dark:text-slate-400\">\n          <FaSpinner className=\"w-5 h-5 animate-spin\" />\n          <span>Loading...</span>\n        </div>\n      </main>\n    )\n  }\n\n  if (!user) {\n    return null\n  }\n\n  return (\n    <main className=\"min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 via-white to-slate-100 dark:from-slate-950 dark:via-slate-900 dark:to-slate-800 p-4\">\n      <motion.div \n        initial={{ opacity: 0, y: 20 }} \n        animate={{ opacity: 1, y: 0 }}\n        transition={{ duration: 0.3 }}\n        className=\"w-full max-w-md\"\n      >\n        <div className=\"bg-white dark:bg-slate-900 rounded-2xl border border-slate-200 dark:border-slate-800 shadow-2xl overflow-hidden\">\n          {/* Header Section */}\n          <div className=\"bg-gradient-to-br from-primary/10 via-primary/5 to-transparent dark:from-primary/20 dark:via-primary/10 p-6 text-center border-b border-slate-200 dark:border-slate-800\">\n            <motion.div \n              initial={{ scale: 0.9 }}\n              animate={{ scale: 1 }}\n              transition={{ delay: 0.1 }}\n              className=\"flex justify-center mb-4\"\n            >\n              <Image \n                src=\"/logo.png\" \n                alt=\"Leenk\" \n                width={80} \n                height={80} \n                className=\"object-contain drop-shadow-lg\" \n              />\n            </motion.div>\n            \n            <motion.h1 \n              initial={{ opacity: 0 }}\n              animate={{ opacity: 1 }}\n              transition={{ delay: 0.2 }}\n              className=\"text-2xl font-bold text-slate-900 dark:text-white mb-2\"\n            >\n              Complete Your Business Profile\n            </motion.h1>\n            \n            <motion.p \n              initial={{ opacity: 0 }}\n              animate={{ opacity: 1 }}\n              transition={{ delay: 0.3 }}\n              className=\"text-sm text-slate-600 dark:text-slate-400\"\n            >\n              Tell us about your business to get started\n            </motion.p>\n          </div>\n\n          {/* Form Section */}\n          <div className=\"p-6 md:p-8\">\n            <form onSubmit={handleComplete} className=\"space-y-5\">\n              {error && (\n                <motion.div\n                  initial={{ opacity: 0, y: -10 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  className=\"p-3 bg-red-50 dark:bg-red-950/30 border border-red-200 dark:border-red-800 rounded-lg text-red-700 dark:text-red-400 text-sm flex items-center gap-2\"\n                >\n                  <FaExclamationCircle className=\"w-4 h-4 flex-shrink-0\" />\n                  <span>{error}</span>\n                </motion.div>\n              )}\n\n              {/* Business Name Input */}\n              <div className=\"space-y-2\">\n                <label className=\"block text-sm font-semibold text-slate-700 dark:text-slate-300\">\n                  Business Name <span className=\"text-red-500\">*</span>\n                </label>\n                <div className=\"relative\">\n                  <FaBuilding className=\"absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400 dark:text-slate-500\" />\n                  <input\n                    type=\"text\"\n                    value={businessName}\n                    onChange={(e) => {\n                      setBusinessName(e.target.value)\n                      setError(\"\")\n                    }}\n                    placeholder=\"Your Business Name\"\n                    className=\"w-full bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 pl-11 py-3 text-slate-900 dark:text-white placeholder:text-slate-400 dark:placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all\"\n                    required\n                    autoFocus\n                  />\n                </div>\n              </div>\n\n              {/* Phone Number Input */}\n              <div className=\"space-y-2\">\n                <label className=\"block text-sm font-semibold text-slate-700 dark:text-slate-300\">\n                  Phone Number <span className=\"text-red-500\">*</span>\n                </label>\n                <div className=\"relative\">\n                  <FiPhone className=\"absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400 dark:text-slate-500\" />\n                  <input\n                    type=\"tel\"\n                    value={phone}\n                    onChange={(e) => {\n                      setPhone(e.target.value)\n                      setError(\"\")\n                    }}\n                    placeholder=\"+1234567890\"\n                    className=\"w-full bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 pl-11 py-3 text-slate-900 dark:text-white placeholder:text-slate-400 dark:placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all\"\n                    required\n                  />\n                </div>\n                <p className=\"text-xs text-slate-500 dark:text-slate-400\">\n                  This will be used for your public chat link\n                </p>\n              </div>\n\n              {/* Address Input */}\n              <div className=\"space-y-2\">\n                <label className=\"block text-sm font-semibold text-slate-700 dark:text-slate-300\">\n                  Business Address <span className=\"text-red-500\">*</span>\n                </label>\n                <div className=\"relative\">\n                  <FaMapMarkerAlt className=\"absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400 dark:text-slate-500\" />\n                  <input\n                    type=\"text\"\n                    value={address}\n                    onChange={(e) => {\n                      setAddress(e.target.value)\n                      setError(\"\")\n                    }}\n                    placeholder=\"123 Main St, City, State, ZIP\"\n                    className=\"w-full bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 pl-11 py-3 text-slate-900 dark:text-white placeholder:text-slate-400 dark:placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all\"\n                    required\n                  />\n                </div>\n              </div>\n\n              {/* Submit Button */}\n              <Button \n                type=\"submit\" \n                className=\"w-full h-12 text-base font-semibold rounded-xl shadow-lg hover:shadow-xl transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed mt-6\"\n                disabled={loading || !businessName.trim() || !phone.trim() || !address.trim()}\n              >\n                {loading ? (\n                  <span className=\"flex items-center gap-2\">\n                    <FaSpinner className=\"w-4 h-4 animate-spin\" />\n                    Completing Setup...\n                  </span>\n                ) : (\n                  <span>Complete Setup</span>\n                )}\n              </Button>\n            </form>\n\n            {/* Footer Note */}\n            <p className=\"text-xs text-center text-slate-500 dark:text-slate-400 mt-6\">\n              All fields are required to complete your business profile\n            </p>\n          </div>\n        </div>\n      </motion.div>\n    </main>\n  )\n}\n"],"names":[],"mappings":"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"}}]
}